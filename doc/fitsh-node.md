# Fitsh 语言节点规则

1. **`let` 只是语法级别的表达式模板**  
   - `let name = expr` 不会立刻占用局部 slot，仅把 `expr` 保存为该符号的模板。`let` 语句本身返回空值，不会生成 `GET`/`PUT`。
   - 每次引用 `name` 时会动态克隆模板并在使用位置展开，等效于“在使用点重新执行 `expr`”。因为没有 slot，`let` 无法直接绑定到 `$N`，只能通过符号名展开。
   - `let` 可以重复绑定同一个符号，只要之前不是 `var`（`var` 定义后不能被 `let` 或其他 `var` 覆写）。这体现了 `let` 与堆栈/slot 彻底无关的宏式语义。

2. **`var` 定义的变量是唯一的、可写的局部 slot**  
   - `var foo = expr` 会在编译时分配 slot 并生成对应的 `PUT` 指令，之后的读取/写入都通过 slot 访问。
   - `var` 不可重复定义，语义上代表一个固定的可写局部变量；如果再出现同名 `var`，会报错。

3. **输出与反编译一致性**  
   - `let` 的反编译结果只会展现克隆后的表达式（例如 `print foo` 反编译输出 `print(expr)`），不会恢复 `let` 声明形式，因为 slot 并未生成。`let` 的语义在反编译中只体现为重复展开同样的模板。
   - `var` 编译为 slot 写入，反编译仍能看到 `var`/`$n` 对应的 slot 操作。
